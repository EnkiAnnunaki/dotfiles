#!/usr/bin/env zsh

if [[ -d "${GDK_ROOT}" ]]; then
  source ~/.config/yadm/scripts/colors.sh
  source ~/.shellrc/rc.d/aliases.sh

  SCRIPT_DIR="${0:a:h}/scripts"

  GITLAB_USERNAME=${USER}

  function rebase-all() {
    ruby -r "${SCRIPT_DIR}/git-helpers.rb" -e rebase_all
  }

  #
  # The gpif function performs a 'git push --force-with-lease' on all branches related to the current branch's issue.
  #
  function gpif() {
    ruby -r "${SCRIPT_DIR}/git-helpers.rb" -e git_push_issue -- $@
  }

  function git_parent() {
    local branch="$1"
    if [[ -z $branch ]]; then
      branch="$(git_current_branch)"
    fi

    # https://stackoverflow.com/a/55238339/209726
    asdf exec ruby -r "${SCRIPT_DIR}/git-helpers.rb" -e "puts compute_parent_branch('${branch}')"
  }

  function wait-gdk-mr-merged() {
    curl -s "http://localhost:8989?action=light&red=100&blue=100"
    while [[ "$(curl -sS https://gitlab.com/api/v4/projects/gitlab-org%2Fgitlab/merge_requests/$1 --header "PRIVATE-TOKEN: $GITLAB_COM_TOKEN" | jq -r .state)" != 'merged' ]]; do
      sleep 5
    done
    curl -s "http://localhost:8989?action=light&green=100"
  }

  unalias gpsup 2>/dev/null

  function gpsup() {
    local remote=origin

    if git remote get-url $remote | grep gitlab.com > /dev/null; then
      git push --set-upstream $remote "$(git_current_branch)" \
        -o merge_request.create \
        -o "merge_request.target=$(git_parent)" \
        -o "merge_request.assign=${GITLAB_USERNAME}" \
        -o "merge_request.label=Category:Runner Fleet" \
        -o "merge_request.label=section::ops" \
        -o "merge_request.label=devops::verify" \
        -o "merge_request.label=group::runner" \
        "$@"
    else
      git push --set-upstream $remote "$(git_current_branch)" "$@"
    fi
  }

  unalias gswm 2>/dev/null

  function gswm() {
    if [[ $PWD/ = ${GDK_ROOT}/* ]]; then
      undo-migrations
      git checkout db/
    fi
    git switch "$(git_main_branch)"
  }

  #
  # diff-structure outputs a clean patch that I can copy/paste (using `diff-structure | pbcopy`) to the SSH session
  # to get the thin clone up to date with my branch
  #
  alias diff-structure="git --no-pager diff -U0 \$(git_main_branch).. -- db/structure.sql | grep '^+[^+]' | sed 's/^+\(.*\)/\1/'"

  function list-migrations() {
    MIGRATIONS_DIFF="$(git diff --name-only --diff-filter=A $(git_main_branch) -- db/schema_migrations/)"
    echo ${MIGRATIONS_DIFF} | xargs basename -a | sort -r
  }

  function undo-migrations() {
    [[ $PWD/ = ${GDK_ROOT}/* ]] || return

    (
      set -e

      BRANCH_MIGRATIONS=( $(list-migrations) )
      if [[ ${#BRANCH_MIGRATIONS[@]} -ne 0 ]]; then
        printf "${YELLOW}%s${NC}\n" "Undoing ${#BRANCH_MIGRATIONS[@]} branch migration(s)..."
        gdk start postgresql
        for migration in "${BRANCH_MIGRATIONS[@]}"; do
          bin/rails db:migrate:down:main VERSION="${migration}"
          bin/rails db:migrate:down:ci VERSION="${migration}"
        done
      fi
    )
  }

  function fgdku() {
    (
      cd "${GDK_ROOT}/gitlab" || exit 0

      curl -s "http://localhost:8989?action=pulse&green=100"

      rm -rf .git/gc.log
      git checkout db/structure.sql

      if [[ ! -S $GDK_ROOT/redis/redis.socket ]]; then
        # Work around issue with Redis socket disappearing by returning to pristine state
        printf "${YELLOW}%s${NC}\n" 'Redis socket disappeared, running gdk pristine before update...'
        gdk pristine
        gdk reconfigure
      fi

      if [[ $(git diff --shortstat 2> /dev/null | tail -n1) != "" ]]; then
        printf "${RED}%s${NC}\n" 'Please stash the changes in the current branch before calling fgdku!'
        cd - >/dev/null
        exit 1
      fi

      set -eo pipefail

      ORIGINAL_BRANCH="$(git_current_branch)"
      MIGRATIONS_DIFF="$(git diff --name-only --diff-filter=A master -- db/schema_migrations/)"
      BRANCH_MIGRATIONS=( $(echo ${MIGRATIONS_DIFF} | xargs basename -a | sort -r) )
      if [[ ${#BRANCH_MIGRATIONS[@]} -ne 0 ]]; then
        undo-migrations
        git stash push -m "Rolled back migration from ${ORIGINAL_BRANCH}"
      fi

      printf "${YELLOW}%s${NC}\n" "Updating GDK..."
      set +e
      gdk update
      if [[ $? -eq 1 && ! -S $GDK_ROOT/redis/redis.socket ]]; then
        # Work around issue with Redis socket disappearing by returning to pristine state and retrying the update
        printf "${YELLOW}%s${NC}\n" 'Redis socket disappeared during update, running gdk pristine before retrying update...'
        gdk pristine
        gdk reconfigure
        gdk update
      fi
      set -eo pipefail

      git checkout db/structure.sql
      sleep 5

      printf "${YELLOW}%s${NC}\n" "Precompiling static assets to ensure graphiql-rails changes are picked up..."
      bundle exec rake rake:assets:precompile

      printf "${YELLOW}%s${NC}\n" "Running simple test..."
      bin/spring stop && bundle exec rails db:test:prepare # Work around issue with multiple databases (https://gitlab.com/gitlab-org/gitlab/-/issues/356656)
      bin/rspec --failure-exit-code 0 --error-exit-code 0 spec/lib/gitlab/ci/variables/collection_spec.rb

      printf "${YELLOW}%s${NC}\n" "Pruning local branches..."
      git fetch --all --prune --jobs=10
      set +e
      git branch -vv | grep -E '(origin|security)/.*: gone]' | awk '{print $1}' | grep -v '^_.*$' | xargs git branch -D
      set -e
      printf "${GREEN}%s${NC}\n" "Done."

      printf "${YELLOW}%s${NC}\n" "Rebasing local branches..."
      git checkout
      rebase-all
      printf "${GREEN}%s${NC}\n" "Done."

      if [[ "${ORIGINAL_BRANCH}" != "$(git_main_branch)" ]]; then
        if git rev-parse --abbrev-ref "${ORIGINAL_BRANCH}" >/dev/null 2>&1; then
          git switch "${ORIGINAL_BRANCH}"
        fi
      fi

      gdk restart

      if [[ ${#BRANCH_MIGRATIONS[@]} -ne 0 ]]; then
        printf "${YELLOW}%s${NC}\n" "Applying stash and migrations..."
        git stash pop
        bin/rails db:migrate
        scripts/regenerate-schema # Ensure we have a clean test DB with any branch migrations done
        git checkout db/structure.sql
      fi

      if ps aux | grep RubyMine.app/Contents/MacOS/rubymine | grep -v "grep"; then
        printf "${YELLOW}%s${NC}\n" "Start indexing in RubyMine..."
        osascript <<END
          tell application "RubyMine"
            activate
          end tell
END
      fi

      printf "${YELLOW}%s${NC}\n" "Warming up web server..."
      curl -sL 'http://gdk.test:3000' -o /dev/null

      cd - >/dev/null
    )

    curl -s "http://localhost:8989?action=light&green=100"
  }

  function _export_op_token() {
    local varname=$1
    echo "Fetching ${varname}..."
    eval "${varname}=$(op --cache item get $varname --vault Private --fields credential)"
    export $varname
  }

  function setup_gitlab_secrets() {
    eval $(op signin --account gitlab)

    _export_op_token GITLAB_COM_TOKEN
    _export_op_token GITLAB_STAGING_TOKEN
    _export_op_token GITLAB_GDK_TOKEN
    echo 'Done'

    op signout
    unset OP_SESSION_gitlab
  }

  function thin-clone() {
    set -o pipefail

    # echo -n "Username (defaults to '${USER}'): "
    # read -r USERNAME
    # echo
    if [[ -z ${USERNAME} ]]; then
      USERNAME="${USER}"
    fi

    POSTGRES_AI_HOST='gitlab-joe-poc.postgres.ai'
    case $1 in
      create)
        PASSENTRY="$(grep "localhost:10000:gitlabhq_dblab:${USERNAME}" ~/.pgpass)"
        if [[ -z ${PASSENTRY} ]]; then
          # Generate random password
          PASSWORD="$(openssl rand -base64 20)"
          export PGPASSWORD="${PASSWORD}"
        else
          printf "${GREEN}%s${NC}\n" "Found entry in ~/.pgpass for ${USERNAME}"
          PASSWORD=$(echo "${PASSENTRY}" | awk -F "\"*:\"*" '{print $5}')
        fi

        printf "${YELLOW}%s${NC}\n" "Starting a tunnel to ${POSTGRES_AI_HOST}"
        ssh dblab-joe -f -N

        printf "${YELLOW}%s${NC}\n" "Creating thin clone for ${USERNAME}..."
        PORT="$(dblab clone create --username "${USERNAME}" --password "${PASSWORD}" | jq -r '.db.port')"
        LOCAL_PORT=10000

        printf "${YELLOW}%s${NC}\n" "Forwarding local port (${LOCAL_PORT}) to the returned port (${PORT}) at ${POSTGRES_AI_HOST}"
        ssh -L "${LOCAL_PORT}:localhost:${PORT}" -f -N "gldatabase@${POSTGRES_AI_HOST}"

        printf "${YELLOW}%s${NC}\n" "Connecting psql to the local port (${LOCAL_PORT}) with random password ${PASSWORD}"
        pgcli -h localhost -p "${LOCAL_PORT}" -U "${USERNAME}" -d gitlabhq_dblab
        ;;
      list)
        printf "${YELLOW}%s${NC}\n" "Listing thin clones for ${USERNAME}"
        dblab instance status | jq --arg username "${USERNAME}" -r '.clones[] | select(.db.username == $username) | .id'
        ;;
      destroy-all)
        printf "${YELLOW}%s${NC}\n" "Listing thin clones for ${USERNAME}"
        IDS=( $(dblab instance status | jq --arg username "${USERNAME}" -r '.clones[] | select(.db.username == $username) | .id') )
        for id in "${IDS[@]}"; do
          printf "${YELLOW}%s${NC}\n" "Destroying clone ${id}..."
          dblab clone destroy -a "${id}"
        done
        ;;
      stop-ssh)
        printf "${YELLOW}%s${NC}\n" 'Stopping SSH processes...'
        ps aux | grep ssh | grep '\-joe' | awk '{print $2}' | xargs kill -9 || echo -n
        ;;
      *)
        printf "${RED}%s${NC}\n" "Unknown command '$1', aborting"
        ;;
    esac

    printf "${GREEN}%s${NC}\n" Done
  }
fi

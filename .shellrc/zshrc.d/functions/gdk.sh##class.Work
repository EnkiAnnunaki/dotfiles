#!/usr/bin/env zsh

if [[ -d "${GDK_ROOT}" ]]; then
  source ~/.config/yadm/scripts/colors.sh

  GITLAB_USERNAME=${USER}

  function _get_default_branch() {
    default_branch='main'
    git show-ref refs/remotes/origin/master >/dev/null && default_branch='master'
    echo $default_branch
  }

  # Assuming that you have branches named "${GITLAB_USERNAME}/${MR_ID}/${SEQ_ID}-branch_description"
  # this method will ensure that branches from the same MR will be rebased correctly, keeping the chain order
  function _rebase-all() {
    local current_branch="$(git branch --show-current)"
    local default_branch="$(_get_default_branch)"

    set -e

    local followup_base_branch="${default_branch}"
    local prev_branch_chain="${current_branch_chain}"
    local branches=( $(git for-each-ref --sort='refname' --shell --format='%(refname)' refs/heads/${GITLAB_USERNAME} | sed "s;'refs/heads/\(.*\)';\1;") )
    for branch in ${branches[@]}; do
      local is_chained_branch=false
      local base_branch="${default_branch}"
      if [[ $branch =~ "${GITLAB_USERNAME}/[0-9]+/[0-9]+-[^/]*$" || $branch =~ "${GITLAB_USERNAME}/[0-9]+-[^/]+$" ]]; then
        base_branch="${followup_base_branch}"
        is_chained_branch=true
      fi

      local current_branch_chain="$(echo -n "${branch}" | sed "s;^\(${GITLAB_USERNAME}/[0-9]*\)/.*$;\1;")"
      if [[ ${current_branch_chain} != ${prev_branch_chain} ]]; then
        base_branch="${default_branch}"
      fi

      printf "${YELLOW}%s${NC}\n" "Rebasing ${branch} onto ${base_branch}..."
      git switch "${base_branch}"
      git rebase --autostash "${base_branch}" "${branch}"

      prev_branch_chain="${current_branch_chain}"
      if [[ $is_chained_branch == true ]]; then
        followup_base_branch="${branch}"
      else
        followup_base_branch="${default_branch}"
      fi

      echo --------
    done

    git switch "${current_branch}"
  }

  function rebase-all() {
    (
      if ! git diff-index --quiet HEAD --; then
        echo 'Please stash the changes in the current branch before calling rebase-all!'
        exit 1
      fi

      _rebase-all
    )
  }

  function git_parent() {
    git show-branch --no-color \
      | sed "s/].*//" \
      | grep "\*" \
      | grep -v "$(git rev-parse --abbrev-ref HEAD)" \
      | head -n1 \
      | sed "s/^.*\[\(.*\)^[0-9]*/\1/"
  }

  function wait-gdk-mr-merged() {
    while [[ "$(curl -sS https://gitlab.com/api/v4/projects/gitlab-org%2Fgitlab/merge_requests/$1 --header "PRIVATE-TOKEN: $GITLAB_COM_TOKEN" | jq -r .state)" != 'merged' ]]; do
      sleep 5
    done
  }

  unalias gpsup 2>/dev/null

  function gpsup() {
    local remote=origin

    if git remote get-url $remote | grep gitlab.com >/dev/null; then
      git push --set-upstream $remote "$(git_current_branch)" \
        -o merge_request.create \
        -o "merge_request.target=$(git_parent)" \
        -o "merge_request.assign=${GITLAB_USERNAME}" \
        -o "merge_request.label=Category:Runner" \
        -o "merge_request.label=section::ops" \
        -o "merge_request.label=devops::verify" \
        -o "merge_request.label=group::runner"
    else
      git push --set-upstream $remote "$(git_current_branch)"
    fi
  }

  function list-migrations() {
    MIGRATIONS_DIFF="$(git diff --name-only --diff-filter=A master -- db/schema_migrations/)"
    echo ${MIGRATIONS_DIFF} | xargs basename -a | sort -r
  }

  function undo-migrations() {
    (
      set -e

      BRANCH_MIGRATIONS=( $(list-migrations) )
      if [[ ${#BRANCH_MIGRATIONS[@]} -ne 0 ]]; then
        # LAST_MIGRATIONS=( $( (ls db/migrate && ls db/post_migrate) | sort -n | tail -n 6 | awk -F '"*_"*' '{print $1}' | sort -nr) )
        # if [[ "${BRANCH_MIGRATIONS[*]}" == "${LAST_MIGRATIONS[*]}" ]]; then
        #   echo "Rolling back ${#LAST_MIGRATIONS[@]} branch migration(s)..."
        #   bin/rails db:rollback STEP=${#LAST_MIGRATIONS[@]}
        # else
          echo "Undoing ${#BRANCH_MIGRATIONS[@]} branch migration(s)..."
          gdk start postgresql
          for migration in "${BRANCH_MIGRATIONS[@]}"; do
            bin/rails db:migrate:down VERSION="${migration}"
          done
        # fi
      fi
    )
  }

  function fgdku() {
    (
      cd "${GDK_ROOT}/gitlab" || exit 0

      rm -rf .git/gc.log
      git checkout db/structure.sql

      if ! git diff-index --quiet HEAD --; then
        echo 'Please stash the changes in the current branch before calling fgdku!'
        cd - >/dev/null
        exit 1
      fi

      set -eo pipefail
      ORIGINAL_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
      MIGRATIONS_DIFF="$(git diff --name-only --diff-filter=A master -- db/schema_migrations/)"
      BRANCH_MIGRATIONS=( $(echo ${MIGRATIONS_DIFF} | xargs basename -a | sort -r) )
      if [[ ${#BRANCH_MIGRATIONS[@]} -ne 0 ]]; then
        undo-migrations
        git stash push -m "Rolled back migration from ${ORIGINAL_BRANCH}"
      fi

      echo "Pruning local branches..."
      git fetch --all --prune --jobs=10
      set +e
      git_prune
      set -e
      echo "Done."

      echo "Updating GDK..."
      gdk update

      git checkout db/structure.sql
      sleep 5

      echo "Precompiling static assets to ensure graphiql-rails changes are picked up..."
      bundle exec rake rake:assets:precompile

      echo "Running simple test..."
      bin/rspec spec/lib/gitlab/ci/variables/collection_spec.rb

      echo "Rebasing local branches..."
      _rebase-all
      echo "Done."

      gdk restart

      [[ "${ORIGINAL_BRANCH}" == "$(git_main_branch)" ]] || git switch "${ORIGINAL_BRANCH}"
      if [[ ${#BRANCH_MIGRATIONS[@]} -ne 0 ]]; then
        echo "Applying stash and migrations..."
        git stash pop
        bin/rails db:migrate
        scripts/regenerate-schema # Ensure we have a clean test DB with any branch migrations done
        git checkout db/structure.sql
      fi

      if ps aux | grep RubyMine.app/Contents/MacOS/rubymine | grep -v "grep"; then
        echo "Start indexing in RubyMine..."
        osascript <<END
          tell application "RubyMine"
            activate
          end tell
END
      fi

      echo "Warming up web server..."
      curl -sL http://gdk.localhost:3000 -o /dev/null

      cd - >/dev/null
    )
  }

  function thin-clone() {
    set -o pipefail

    # echo -n "Username (defaults to '${USER}'): "
    # read -r USERNAME
    # echo
    if [[ -z ${USERNAME} ]]; then
      USERNAME="${USER}"
    fi

    POSTGRES_AI_HOST='gitlab-joe-poc.postgres.ai'
    case $1 in
      create)
        PASSENTRY="$(grep "localhost:10000:gitlabhq_dblab:${USERNAME}" ~/.pgpass)"
        if [[ -z ${PASSENTRY} ]]; then
          # Generate random password
          PASSWORD="$(openssl rand -base64 20)"
          export PGPASSWORD="${PASSWORD}"
        else
          echo "Found entry in ~/.pgpass for ${USERNAME}"
          PASSWORD=$(echo "${PASSENTRY}" | awk -F "\"*:\"*" '{print $5}')
        fi

        echo "Starting a tunnel to ${POSTGRES_AI_HOST}"
        ssh dblab-joe -f -N

        echo "Creating thin clone for ${USERNAME}..."
        PORT="$(dblab clone create --username "${USERNAME}" --password "${PASSWORD}" | jq -r '.db.port')"
        LOCAL_PORT=10000

        echo "Forwarding local port (${LOCAL_PORT}) to the returned port (${PORT}) at ${POSTGRES_AI_HOST}"
        ssh -L "${LOCAL_PORT}:localhost:${PORT}" -f -N "gldatabase@${POSTGRES_AI_HOST}"

        echo "Connecting psql to the local port (${LOCAL_PORT}) with random password ${PASSWORD}"
        pgcli -h localhost -p "${LOCAL_PORT}" -U "${USERNAME}" -d gitlabhq_dblab
        ;;
      list)
        echo "Listing thin clones for ${USERNAME}"
        dblab instance status | jq --arg username "${USERNAME}" -r '.clones[] | select(.db.username == $username) | .id'
        ;;
      destroy-all)
        echo "Listing thin clones for ${USERNAME}"
        IDS=( $(dblab instance status | jq --arg username "${USERNAME}" -r '.clones[] | select(.db.username == $username) | .id') )
        for id in "${IDS[@]}"; do
          echo "Destroying clone ${id}..."
          dblab clone destroy -a "${id}"
        done
        ;;
      stop-ssh)
        echo 'Stopping SSH processes...'
        ps aux | grep ssh | grep '\-joe' | awk '{print $2}' | xargs kill -9 || echo -n
        ;;
      *)
        echo "Unknown command '$1', aborting"
        ;;
    esac

    echo Done
  }
fi
